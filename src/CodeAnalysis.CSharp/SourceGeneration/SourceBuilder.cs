using MaSch.CodeAnalysis.CSharp.Common;
using MaSch.CodeAnalysis.CSharp.SourceGeneration.Builders;
using MaSch.CodeAnalysis.CSharp.SourceGeneration.Configuration;

namespace MaSch.CodeAnalysis.CSharp.SourceGeneration;

/// <summary>
/// Represents an in-memory source file.
/// </summary>
public sealed partial class SourceBuilder
{
    /// <summary>
    /// The file header that is added to all source files generated using the <see cref="SourceBuilder"/> if <see cref="SourceBuilderOptions.IncludeFileHeader"/> is set to <c>true</c>.
    /// </summary>
    public static readonly string AutoGeneratedFileHeader = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

";

    private const char IndentChar = ' ';

    private readonly StringBuilder _builder;
    private bool _isLineIndented = false;
    private bool _isLastLineEmpty;
    private bool _isCurrentLineEmpty;

    private SourceBuilder(SourceBuilderOptions options)
    {
        Options = options;
        if (options.IncludeFileHeader)
            _builder = new StringBuilder(AutoGeneratedFileHeader, options.Capacity);
        else
            _builder = new StringBuilder(options.Capacity);

        _isLastLineEmpty = true;
        _isCurrentLineEmpty = true;
    }

    /// <inheritdoc cref="ISourceBuilder.Options"/>
    public SourceBuilderOptions Options { get; }

    /// <inheritdoc cref="ISourceBuilder.CurrentIndentLevel"/>
    public int CurrentIndentLevel { get; set; }

    /// <inheritdoc cref="ISourceBuilder.CurrentTypeName"/>
    public string? CurrentTypeName { get; set; }

    /// <summary>
    /// Creates a new source file builder.
    /// </summary>
    /// <param name="options">The options to use for this <see cref="SourceBuilder"/>.</param>
    /// <returns>The newly created source file builder.</returns>
    public static ISourceFileBuilder Create(SourceBuilderOptions options)
    {
        return new SourceBuilder(options);
    }

    /// <summary>
    /// Creates a new source file builder using the default options.
    /// </summary>
    /// <returns>The newly created source file builder.</returns>
    public static ISourceFileBuilder Create()
    {
        return new SourceBuilder(SourceBuilderOptions.Default);
    }

    /// <inheritdoc cref="ISourceBuilder.AppendRegion(string)" />
    public SourceBuilderCodeBlock AppendRegion(string regionName)
    {
        _ = AppendLine($"#region {regionName}");
        return new SourceBuilderCodeBlock(this, "#endregion", false);
    }

    /// <inheritdoc cref="ISourceBuilder.AppendBlock(string)" />
    public SourceBuilderCodeBlock AppendBlock(string blockLine)
    {
        return AppendBlock(blockLine, false);
    }

    /// <inheritdoc cref="ISourceBuilder.AppendBlock(string, bool)" />
    public SourceBuilderCodeBlock AppendBlock(string blockLine, bool addSemicolon)
    {
        _ = AppendLine(blockLine);
        return AppendBlock(addSemicolon);
    }

    /// <inheritdoc cref="ISourceBuilder.AppendBlock()" />
    public SourceBuilderCodeBlock AppendBlock()
    {
        return AppendBlock(false);
    }

    /// <inheritdoc cref="ISourceBuilder.AppendBlock(bool)" />
    public SourceBuilderCodeBlock AppendBlock(bool addSemicolon)
    {
        _ = AppendLine("{");
        return new SourceBuilderCodeBlock(this, addSemicolon ? "};" : "}", true);
    }

    /// <inheritdoc cref="ISourceBuilder.Indent()" />
    public SourceBuilderCodeBlock Indent()
    {
        return new SourceBuilderCodeBlock(this, null, true);
    }

    /// <inheritdoc cref="ISourceBuilder.AppendLine()" />
    public SourceBuilder AppendLine()
    {
        return Append(Environment.NewLine);
    }

    /// <inheritdoc cref="ISourceBuilder.AppendLine(string)" />
    public SourceBuilder AppendLine(string value)
    {
        return Append(value + Environment.NewLine);
    }

    /// <inheritdoc cref="ISourceBuilder.EnsurePreviousLineEmpty()" />
    public SourceBuilder EnsurePreviousLineEmpty()
    {
        if (!_isLastLineEmpty)
            AppendLine();
        return this;
    }

    /// <inheritdoc cref="ISourceBuilder.Append(string)" />
    public SourceBuilder Append(string value)
    {
        if (value is null || value.Length == 0)
            return this;

        var indentCount = CurrentIndentLevel * Options.IndentSize;
        var lineStartIndex = 0;

        for (int i = 0; i < value.Length - 1; i++)
        {
            if (value[i] is '\r')
                i++;

            if (value[i] is '\n')
            {
                var lineLength = i - lineStartIndex;
                if (i > 0 && value[i - 1] is '\r')
                    lineLength--;

                if (lineLength > 0)
                {
                    if (CurrentIndentLevel > 0 && !_isLineIndented)
                        _ = _builder.Append(IndentChar, indentCount);
                    _ = _builder.Append(value, lineStartIndex, lineLength);
                }

                _isLastLineEmpty = _isCurrentLineEmpty;
                _ = _builder.AppendLine();
                _isCurrentLineEmpty = true;
                _isLineIndented = false;

                lineStartIndex = i + 1;
            }

            if (!char.IsWhiteSpace(value[i]) && value[i] is not '{')
                _isCurrentLineEmpty = false;
        }

        if (CurrentIndentLevel > 0 && !_isLineIndented && lineStartIndex < value.Length - 1)
        {
            _ = _builder.Append(IndentChar, indentCount);
            _isLineIndented = true;
        }

        _ = _builder.Append(value, lineStartIndex, value.Length - lineStartIndex);
        return this;
    }

    /// <inheritdoc cref="ISourceBuilder.Append(char)" />
    public SourceBuilder Append(char value)
    {
        if (CurrentIndentLevel > 0 && !_isLineIndented)
        {
            _builder.Append(IndentChar, CurrentIndentLevel * Options.IndentSize);
            _isLineIndented = CurrentIndentLevel > 0;
        }

        _builder.Append(value);
        if (value is '\n')
        {
            _isLastLineEmpty = _isCurrentLineEmpty;
            _isCurrentLineEmpty = true;
            _isLineIndented = false;
        }
        else if (value is not '{')
        {
            _isCurrentLineEmpty = false;
        }

        return this;
    }

    /// <inheritdoc cref="ISourceBuilder.As{T}" />
    public T As<T>()
        where T : ISourceBuilder
        => (T)(ISourceBuilder)this;

    /// <inheritdoc cref="ISourceBuilder.ToSourceText(Encoding?, SourceHashAlgorithm)"/>
    public SourceText ToSourceText(Encoding? encoding = null, SourceHashAlgorithm checksumAlgorithm = SourceHashAlgorithm.Sha1)
    {
        encoding ??= Encoding.UTF8;
        const int LargeObjectHeapLimitInChars = 40 * 1024;
        if (_builder.Length >= LargeObjectHeapLimitInChars)
        {
            using var reader = new StringBuilderReader(_builder);
            return SourceText.From(reader, _builder.Length, encoding, checksumAlgorithm);
        }

        return SourceText.From(_builder.ToString(), encoding, checksumAlgorithm);
    }

    /// <inheritdoc/>
    public override string ToString()
    {
        return _builder.ToString();
    }

    private SourceBuilder AppendAsBlock<T>(ICodeConfiguration configuration, T builder, Action<T> builderFunc)
        where T : ISourceBuilder
    {
        configuration.WriteTo(this);
        using (AppendLine().AppendBlock())
        {
            if (configuration is ITypeConfiguration typeConfiguration)
                CurrentTypeName = typeConfiguration.MemberNameWithoutGenericParameters;
            builderFunc(builder);
        }

        return this;
    }

    private SourceBuilder AppendAsExpression<T>(ICodeConfiguration configuration, T builder, Action<T> builderFunc, bool appendLineBreak)
        where T : ISourceBuilder
    {
        configuration.WriteTo(this);
        using (Indent())
        {
            if (appendLineBreak)
                AppendLine();
            else
                Append(' ');
            Append("=> ");
            builderFunc(builder);
        }

        return this;
    }

    private SourceBuilder AppendWithLineTerminator(ICodeConfiguration configuration, bool appendLine = true)
    {
        configuration.WriteTo(this);
        Append(';');
        if (appendLine)
            AppendLine();
        return this;
    }

    private SourceBuilder EnsurePreviousLineEmpty(bool condition)
        => condition ? EnsurePreviousLineEmpty() : this;

    private SourceBuilder Append(INamespaceImportConfiguration namespaceImportConfiguration)
        => AppendWithLineTerminator(namespaceImportConfiguration);

    private SourceBuilder Append(INamespaceConfiguration namespaceConfiguration, Action<INamespaceBuilder>? builderFunc)
    {
        EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeNamespaces);

        if (builderFunc is null)
            return AppendWithLineTerminator(namespaceConfiguration);

        return AppendAsBlock(namespaceConfiguration, this, builderFunc);
    }

    private SourceBuilder Append(IClassConfiguration classConfiguration, Action<IClassBuilder> builderFunc)
        => EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeTypes).AppendAsBlock(classConfiguration, this, builderFunc);

    private SourceBuilder Append(IInterfaceConfguration interfaceConfguration, Action<IInterfaceBuilder> builderFunc)
        => EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeTypes).AppendAsBlock(interfaceConfguration, this, builderFunc);

    private SourceBuilder Append(IRecordConfiguration recordConfiguration, Action<IRecordBuilder>? builderFunc)
    {
        EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeTypes);

        if (builderFunc is null)
            return AppendWithLineTerminator(recordConfiguration);

        return AppendAsBlock(recordConfiguration, this, builderFunc);
    }

    private SourceBuilder Append(IStructConfiguration structConfiguration, Action<IStructBuilder> builderFunc)
        => EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeTypes).AppendAsBlock(structConfiguration, this, builderFunc);

    private SourceBuilder Append(IEnumConfiguration enumConfiguration, Action<IEnumBuilder> builderFunc)
        => EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeTypes).AppendAsBlock(enumConfiguration, this, builderFunc);

    private SourceBuilder Append(IDelegateConfiguration delegateConfiguration)
        => EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeTypes).AppendWithLineTerminator(delegateConfiguration);

    private SourceBuilder Append(IConstructorConfiguration constructorConfiguration, Action<ISourceBuilder> builderFunc)
        => EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeConstructors).AppendAs(constructorConfiguration.BodyType, constructorConfiguration, builderFunc);

    private SourceBuilder Append(IStaticConstructorConfiguration staticConstructorConfiguration, Action<ISourceBuilder> builderFunc)
        => EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeConstructors).AppendAs(staticConstructorConfiguration.BodyType, staticConstructorConfiguration, builderFunc);

    private SourceBuilder Append(IFinalizerConfiguration finalizerConfiguration, Action<ISourceBuilder> builderFunc)
        => EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeConstructors).AppendAs(finalizerConfiguration.BodyType, finalizerConfiguration, builderFunc);

    private SourceBuilder Append(IFieldConfiguration fieldConfiguration)
        => EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeFields).AppendWithLineTerminator(fieldConfiguration);

    private SourceBuilder Append(IEventConfiguration eventConfiguration, Action<ISourceBuilder>? addMethodBuilderFunc, Action<ISourceBuilder>? removeMethodBuilderFunc)
    {
        EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeProperties);

        if (addMethodBuilderFunc is null || removeMethodBuilderFunc is null)
            return AppendWithLineTerminator(eventConfiguration);

        eventConfiguration.WriteTo(this);
        using (AppendLine().AppendBlock())
        {
            Append(eventConfiguration.AddMethod, addMethodBuilderFunc);
            Append(eventConfiguration.RemoveMethod, removeMethodBuilderFunc);
        }

        return this;
    }

    private SourceBuilder Append(IEventMethodConfiguration eventMethodConfiguration, Action<ISourceBuilder> builderFunc)
        => AppendAs(eventMethodConfiguration.BodyType, eventMethodConfiguration, builderFunc);

    private SourceBuilder Append(IPropertyConfigurationBase propertyConfiguration, Action<ISourceBuilder>? getBuilderFunc, Action<ISourceBuilder>? setBuilderFunc)
    {
        EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeProperties);

        var readOnlyPropertyConfiguration = propertyConfiguration as IReadOnlyPropertyConfigurationBase;
        if (readOnlyPropertyConfiguration?.GetBodyType is PropertyGetMethodType.Expression or PropertyGetMethodType.ExpressionNewLine &&
            getBuilderFunc is not null)
        {
            return AppendAsExpression(propertyConfiguration, this, getBuilderFunc, readOnlyPropertyConfiguration.GetBodyType is PropertyGetMethodType.ExpressionNewLine);
        }

        propertyConfiguration.WriteTo(this);
        var getConfig = (propertyConfiguration as IPropertyHasGetConfiguration)?.GetMethod;
        var setConfig = (propertyConfiguration as IPropertyHasSetConfiguration)?.SetMethod;
        var multiline =
            getConfig.ShouldBeOnItsOwnLine ||
            setConfig.ShouldBeOnItsOwnLine ||
            getBuilderFunc is not null ||
            setBuilderFunc is not null;

        SourceBuilderCodeBlock block;
        if (multiline)
        {
            block = AppendLine().AppendBlock();
        }
        else
        {
            Append("{ ");
            block = Indent();
        }

        using (block)
        {
            if (getConfig is not null && readOnlyPropertyConfiguration?.GetBodyType is not PropertyGetMethodType.Initialize)
                Append(getConfig, getBuilderFunc, multiline);
            if (setConfig is not null)
                Append(setConfig, getBuilderFunc, multiline);
        }

        if (!multiline)
            Append(" }");

        if (readOnlyPropertyConfiguration?.GetBodyType is PropertyGetMethodType.Initialize && getBuilderFunc is not null)
        {
            Append(" = ");
            getBuilderFunc(this);
            Append(';');
        }

        return this;
    }

    private SourceBuilder Append(IPropertyMethodConfiguration propertyMethodConfiguration, Action<ISourceBuilder>? builderFunc, bool multiline)
        => AppendAs(propertyMethodConfiguration.BodyType, propertyMethodConfiguration, builderFunc, multiline);

    private SourceBuilder Append(IMethodConfiguration methodConfiguration, Action<ISourceBuilder>? builderFunc)
        => EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeMethods).AppendAs(methodConfiguration.BodyType, methodConfiguration, builderFunc);

    private SourceBuilder Append(IEnumValueConfiguration enumValueConfiguration)
    {
        EnsurePreviousLineEmpty(Options.EnsureEmptyLineBeforeEnumValues);
        enumValueConfiguration.WriteTo(this);
        return Append(',').AppendLine();
    }

    private SourceBuilder Append(ICodeAttributeConfiguration codeAttributeConfiguration, bool appendLine = true)
    {
        codeAttributeConfiguration.WriteTo(this);
        return appendLine ? AppendLine() : Append(' ');
    }

    private SourceBuilder AppendAs(MethodBodyType bodyType, ICodeConfiguration codeConfiguration, Action<ISourceBuilder> builderFunc, bool appendLineAfterTerminator = true)
    {
        if (builderFunc is null)
            return AppendWithLineTerminator(codeConfiguration, appendLineAfterTerminator);

        if (bodyType is MethodBodyType.Expression or MethodBodyType.ExpressionNewLine)
            return AppendAsExpression(codeConfiguration, this, builderFunc, bodyType is MethodBodyType.ExpressionNewLine);

        return AppendAsBlock(codeConfiguration, this, builderFunc);
    }
}