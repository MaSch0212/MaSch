using MaSch.CodeAnalysis.CSharp.Common;

namespace MaSch.CodeAnalysis.CSharp.SourceGeneration;

/// <summary>
/// Represents an in-memory source file.
/// </summary>
public class SourceBuilder : ISourceBuilder, ISourceFileBuilder
{
    /// <summary>
    /// The file header that is added to all source files generated using the <see cref="SourceBuilder"/>.
    /// </summary>
    public static readonly string AutoGeneratedFileHeader = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

";

    private const char IndentChar = ' ';
    private const int StartCapacity = 16 * 1024; // 16KB

    private readonly StringBuilder _builder;
    private bool _isLineIndented = false;

    private SourceBuilder(int indentSize, int capacity, bool autoAddFileHeader)
    {
        IndentSize = indentSize;
        _builder = new StringBuilder(autoAddFileHeader ? AutoGeneratedFileHeader : string.Empty, capacity);
    }

    /// <inheritdoc/>
    public int IndentSize { get; }

    /// <inheritdoc/>
    public int CurrentIndentLevel { get; set; }

    /// <summary>
    /// Creates a new source file builder.
    /// </summary>
    /// <param name="indentSize">The number of whitespace characters to use when indenting.</param>
    /// <param name="capacity">The suggested starting size of the <see cref="SourceBuilder"/>.</param>
    /// <param name="autoAddFileHeader">Determines whether a file header should be automatically added that informs users and IDEs, that the source is auto-generated (see <see cref="AutoGeneratedFileHeader"/>).</param>
    /// <returns>The newly created source file builder.</returns>
    public static ISourceFileBuilder Create(int indentSize = 4, int capacity = StartCapacity, bool autoAddFileHeader = true)
    {
        return new SourceBuilder(indentSize, capacity, autoAddFileHeader);
    }

    /// <inheritdoc cref="ISourceBuilder.AppendRegion(string)" />
    public SourceBuilderCodeBlock AppendRegion(string regionName)
    {
        _ = AppendLine($"#region {regionName}");
        return new SourceBuilderCodeBlock(this, "#endregion", false);
    }

    /// <inheritdoc cref="ISourceBuilder.AppendBlock(string)" />
    public SourceBuilderCodeBlock AppendBlock(string blockLine)
    {
        return AppendBlock(blockLine, false);
    }

    /// <inheritdoc cref="ISourceBuilder.AppendBlock(string, bool)" />
    public SourceBuilderCodeBlock AppendBlock(string blockLine, bool addSemicolon)
    {
        _ = AppendLine(blockLine);
        return AppendBlock(addSemicolon);
    }

    /// <inheritdoc cref="ISourceBuilder.AppendBlock()" />
    public SourceBuilderCodeBlock AppendBlock()
    {
        return AppendBlock(false);
    }

    /// <inheritdoc cref="ISourceBuilder.AppendBlock(bool)" />
    public SourceBuilderCodeBlock AppendBlock(bool addSemicolon)
    {
        _ = AppendLine("{");
        return new SourceBuilderCodeBlock(this, addSemicolon ? "};" : "}", true);
    }

    /// <inheritdoc cref="ISourceBuilder.AppendLine()" />
    public SourceBuilder AppendLine()
    {
        return Append(Environment.NewLine);
    }

    /// <inheritdoc cref="ISourceBuilder.AppendLine(string)" />
    public SourceBuilder AppendLine(string value)
    {
        return Append(value + Environment.NewLine);
    }

    /// <inheritdoc cref="ISourceBuilder.Append(string)" />
    public SourceBuilder Append(string value)
    {
        if (CurrentIndentLevel == 0)
        {
            _builder.Append(value);
            return this;
        }

        var indentCount = CurrentIndentLevel * IndentSize;
        var lineStartIndex = 0;

        for (int i = 0; i < value.Length - 1; i++)
        {
            if (value[i] is '\r')
                i++;

            if (value[i] is '\n')
            {
                var lineLength = i - lineStartIndex;
                if (i > 0 && value[i - 1] is '\r')
                    lineLength--;

                if (lineLength > 0)
                {
                    if (!_isLineIndented)
                        _ = _builder.Append(IndentChar, indentCount);
                    _ = _builder.Append(value, lineStartIndex, lineLength);
                }

                _ = _builder.AppendLine();

                lineStartIndex = i + 1;
            }
        }

        if (!_isLineIndented && lineStartIndex < value.Length - 1)
        {
            _ = _builder.Append(IndentChar, indentCount);
            _isLineIndented = true;
        }

        _ = _builder.Append(value, lineStartIndex, value.Length - lineStartIndex);
        return this;
    }

    /// <inheritdoc cref="ISourceBuilder.Append(char)" />
    public SourceBuilder Append(char value)
    {
        if (CurrentIndentLevel > 0 && !_isLineIndented)
        {
            _builder.Append(IndentChar, CurrentIndentLevel * IndentSize);
            _isLineIndented = CurrentIndentLevel > 0;
        }

        _builder.Append(value);
        if (value is '\n')
            _isLineIndented = false;
        return this;
    }

    /// <inheritdoc/>
    public override string ToString()
    {
        return _builder.ToString();
    }

    /// <inheritdoc/>
    public SourceText ToSourceText(Encoding? encoding = null, SourceHashAlgorithm checksumAlgorithm = SourceHashAlgorithm.Sha1)
    {
        encoding ??= Encoding.UTF8;
        const int LargeObjectHeapLimitInChars = 40 * 1024;
        if (_builder.Length >= LargeObjectHeapLimitInChars)
        {
            using var reader = new StringBuilderReader(_builder);
            return SourceText.From(reader, _builder.Length, encoding, checksumAlgorithm);
        }

        return SourceText.From(_builder.ToString(), encoding, checksumAlgorithm);
    }

    #region ISourceBuilder

    /// <inheritdoc/>
    ISourceBuilder ISourceBuilder.AppendLine() => AppendLine();

    /// <inheritdoc/>
    ISourceBuilder ISourceBuilder.AppendLine(string value) => AppendLine(value);

    /// <inheritdoc/>
    ISourceBuilder ISourceBuilder.Append(string value) => Append(value);

    /// <inheritdoc/>
    ISourceBuilder ISourceBuilder.Append(char value) => Append(value);

    /// <inheritdoc/>
    T ISourceBuilder.As<T>()
        => (T)(ISourceBuilder)this;

    /// <inheritdoc/>
    ISourceFileBuilder ISourceBuilder<ISourceFileBuilder>.AppendLine() => AppendLine();

    /// <inheritdoc/>
    ISourceFileBuilder ISourceBuilder<ISourceFileBuilder>.AppendLine(string value) => AppendLine(value);

    /// <inheritdoc/>
    ISourceFileBuilder ISourceBuilder<ISourceFileBuilder>.Append(string value) => Append(value);

    /// <inheritdoc/>
    ISourceFileBuilder ISourceBuilder<ISourceFileBuilder>.Append(char value) => Append(value);

    #endregion

    #region ISourceNamespaceImportBuilder

    /// <inheritdoc/>
    ISourceFileBuilder ISourceNamespaceImportBuilder<ISourceFileBuilder>.AppendNamespaceImport(string @namespace) => AppendNamespaceImport(@namespace);

    /// <inheritdoc/>
    ISourceFileBuilder ISourceNamespaceImportBuilder<ISourceFileBuilder>.AppendNamespaceImport(string @namespace, string alias) => AppendNamespaceImport(@namespace, alias);

    /// <inheritdoc/>
    ISourceFileBuilder ISourceNamespaceImportBuilder<ISourceFileBuilder>.AppendStaticNamespaceImport(string @namespace) => AppendStaticNamespaceImport(@namespace);

    /// <inheritdoc/>
    ISourceFileBuilder ISourceNamespaceImportBuilder<ISourceFileBuilder>.AppendGlobalNamespaceImport(string @namespace) => AppendGlobalNamespaceImport(@namespace);

    /// <inheritdoc/>
    ISourceFileBuilder ISourceNamespaceImportBuilder<ISourceFileBuilder>.AppendGlobalNamespaceImport(string @namespace, string alias) => AppendGlobalNamespaceImport(@namespace, alias);

    /// <inheritdoc/>
    ISourceFileBuilder ISourceNamespaceImportBuilder<ISourceFileBuilder>.AppendGlobalStaticNamespaceImport(string @namespace) => AppendGlobalStaticNamespaceImport(@namespace);

    #endregion

    private SourceBuilder AppendNamespaceImport(string @namespace)
        => AppendLine($"using {@namespace};");

    private SourceBuilder AppendNamespaceImport(string @namespace, string alias)
        => string.IsNullOrEmpty(alias) ? AppendNamespaceImport(@namespace) : AppendLine($"using {alias} = {@namespace};");

    private SourceBuilder AppendStaticNamespaceImport(string @namespace)
        => AppendLine($"using static {@namespace};");

    private SourceBuilder AppendGlobalNamespaceImport(string @namespace)
        => Append("global ").AppendNamespaceImport(@namespace);

    private SourceBuilder AppendGlobalNamespaceImport(string @namespace, string alias)
        => Append("global ").AppendNamespaceImport(@namespace, alias);

    private SourceBuilder AppendGlobalStaticNamespaceImport(string @namespace)
        => Append("global ").AppendStaticNamespaceImport(@namespace);
}