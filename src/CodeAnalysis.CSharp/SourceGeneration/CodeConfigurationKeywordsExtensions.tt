<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#
    var data = new Dictionary<string, (string[] AccessModifiers, string[] Keywords)>
    {
        ["IClassConfiguration"] = (
            new[] { "public", "private", "protected", "internal", "protected internal", "private protected", "file" },
            Combine(Combine(new[] { "static", "sealed", "abstract" }, "unsafe"), "partial").ToArray()
        ),
        ["IConstructorConfiguration"] = (
            new[] { "public", "private", "protected", "internal", "protected internal", "private protected" },
            new[] { "unsafe" }
        ),
        ["IDelegateConfiguration"] = (
            new[] { "public", "private", "protected", "internal", "protected internal", "private protected" },
            Combine(new[] { "static", "new" }, "unsafe").ToArray()
        ),
        ["IMethodConfiguration"] = (
            new[] { "public", "private", "protected", "internal", "protected internal", "private protected" },
            Combine(
                Combine(
                    new[] { "static", "new", "override", "abstract", "virtual", "new abstract", "new virtual" },
                    "extern",
                    new[] { "abstract" })
                    .Concat(new[] { "partial", "static partial" }),
                "unsafe").ToArray()
        ),
        ["IEventConfiguration"] = (
            new[] { "public", "private", "protected", "internal", "protected internal", "private protected" },
            Combine(
                new[] { "static", "new", "override", "abstract", "virtual", "new abstract", "new virtual" },
                "unsafe").ToArray()
        ),
        ["IFieldConfiguration"] = (
            new[] { "public", "private", "protected", "internal", "protected internal", "private protected" },
            Combine(
                Combine(
                    new[] { "static", "new" },
                    "unsafe"),
                new[] { "readonly", "ref readonly" }).ToArray()
        ),
        ["IPropertyConfigurationBase<T>"] = (
            new[] { "public", "private", "protected", "internal", "protected internal", "private protected" },
            Combine(
                new[] { "static", "new", "override", "abstract", "virtual", "new abstract", "new virtual" },
                "unsafe").ToArray()
        ),
        ["IInterfaceConfguration"] = (
            new[] { "public", "private", "protected", "internal", "protected internal", "private protected", "file" },
            Combine(new[] { "unsafe" }, "partial").ToArray()
        ),
        ["IRecordConfiguration"] = (
            new[] { "public", "private", "protected", "internal", "protected internal", "private protected", "file" },
            Combine(Combine(new[] { "sealed", "abstract" }, "unsafe"), "partial").ToArray()
        ),
        ["IStructConfiguration"] = (
            new[] { "public", "private", "protected", "internal", "protected internal", "private protected", "file" },
            Combine(Combine(Combine(new[] { "readonly" }, "unsafe"), "ref"), "partial").ToArray()
        ),
    };
    
    var sb = new StringBuilder();
    
    sb.AppendLine("""
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by a tool.
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------

        using MaSch.CodeAnalysis.CSharp.SourceGeneration.Configuration;
    
        namespace MaSch.CodeAnalysis.CSharp.SourceGeneration;
        """);
    
    foreach (var typeName in data.Keys)
    {
        var (accessModifiers, keywordCombinations) = data[typeName];

        sb.Append($$"""
            
            /// <summary>
            /// Provides extension methods for the different possible keyword combinations of code configurations.
            /// </summary>
            public static class {{typeName.Substring(1).Replace("<T>", string.Empty)}}KeywordsExtensions
            {
            """);
        
        foreach (var keywords in keywordCombinations)
        {
            sb.AppendLine($$"""
                
                    /// <summary>
                    /// Marks the code configuration as <c>{{keywords}}</c>.
                    /// </summary>
                    /// <typeparam name="T">The type of code configuration.</typeparam>
                    /// <param name="config">The code configuration to change.</param>
                    /// <returns>A self-reference to <paramref name="config"/>.</returns>
                    public static T {{GetMethodName(null, keywords)}}<T>(this T config)
                        where T : {{typeName}}
                    {
                        config.WithKeyword({{GetKeywordsCode(keywords)}});
                        return config;
                    }
                """);
        }

        foreach (var accessModifier in accessModifiers)
        {
            foreach (var keywords in keywordCombinations)
            {
                sb.AppendLine($$"""
                    
                        /// <summary>
                        /// Marks the code configuration as <c>{{accessModifier}} {{keywords}}</c>.
                        /// </summary>
                        /// <typeparam name="T">The type of code configuration.</typeparam>
                        /// <param name="config">The code configuration to change.</param>
                        /// <returns>A self-reference to <paramref name="config"/>.</returns>
                        public static T {{GetMethodName(accessModifier, keywords)}}<T>(this T config)
                            where T : {{typeName}}
                        {
                            config.WithAccessModifier({{GetAccessModifierCode(accessModifier)}}).WithKeyword({{GetKeywordsCode(keywords)}});
                            return config;
                        }
                    """);
            }
        }

        sb.AppendLine("}");
    }
    
    Write(sb.ToString());

#>
<#+
    static IEnumerable<string> Combine(IEnumerable<string> a, string b)
    {
        return Combine(a, b, Enumerable.Empty<string>());
    }

    static IEnumerable<string> Combine(IEnumerable<string> a, IEnumerable<string> b)
    {
        return Combine(a, b, Enumerable.Empty<string>());
    }
    
    static IEnumerable<string> Combine(IEnumerable<string> a, string b, IEnumerable<string> blacklist)
    {
        return Combine(a, new[] { b }, blacklist);
    }

    static IEnumerable<string> Combine(IEnumerable<string> a, IEnumerable<string> b, IEnumerable<string> blacklist)
    {
        foreach (var i in a)
            yield return i;

        foreach (var i in b)
            yield return i;
    
        foreach (var i in a)
        {
            if (blacklist.Any(x => i.Contains(x)))
                continue;
            foreach (var j in b)
                yield return $"{i} {j}";
        }
    }

    static string GetAccessModifierCode(string accessModifier)
    {
        return $"AccessModifier.{GetAccessModifierName(accessModifier)}";
    }

    static string GetKeywordsCode(string keywords)
    {
        return string.Join(" | ", GetKeywordNames(keywords).Select(x => $"MemberKeyword.{x}"));
    }

    static IEnumerable<string> GetKeywordNames(string keywords)
    {
        return keywords.Split(' ')
            .Select(x =>
            {
                return x switch
                {
                    "readonly" => "ReadOnly",
                    _ => x[0].ToString().ToUpperInvariant() + x.Substring(1),
                };
            });
    }

    static string GetAccessModifierName(string accessModifier)
    {
        if (string.IsNullOrEmpty(accessModifier))
            return string.Empty;
        return string.Concat(accessModifier.Split(' ').Select(x => x[0].ToString().ToUpperInvariant() + x.Substring(1)));
    }

    static string GetMethodName(string accessModifier, string keywords)
    {
        return "As" + string.Concat(GetKeywordNames(keywords).Prepend(GetAccessModifierName(accessModifier)));
    }
#>