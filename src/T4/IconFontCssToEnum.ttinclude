<#@ assembly name="System.Core" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Runtime.Remoting.Messaging" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ include file="T4Common.ttinclude" #>
<#+
    public void GenerateEnumFromCss(string cssRelativePath, string prefix, uint extraIdStart, Dictionary<string, string> extraGeometries, string suffix = null)
    {
        var filePath = Host.ResolvePath(cssRelativePath);
        var regex = new Regex($@"\.{Regex.Escape(prefix)}(?<name>[^:]*){Regex.Escape(suffix ?? string.Empty)}:?:before\s*{{\s*content:\s*""\\(?<code>[0-9a-fA-F]*)"";\s*}}");
        var fileContent = File.ReadAllText(filePath);
        var codes = GetCodes(regex, fileContent).ToArray();
        var enumName = Path.GetFileNameWithoutExtension(Host.TemplateFile);

        var sb = new StringBuilder(@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

");

        sb.AppendLine("using System;")
          .AppendLine("using System.Collections.Generic;")
          .AppendLine("using System.Text;")
          .AppendLine()
          .AppendLine($"namespace {GetNamespaceHint()}")
          .AppendLine("{");


        sb.AppendLine($"    internal static class {enumName}CharMapper")
          .AppendLine($"    {{")
          .AppendLine($"        private static readonly Dictionary<{enumName}, string> GeometryPaths = new Dictionary<{enumName}, string>")
          .AppendLine($"        {{");
        if (extraGeometries != null && extraGeometries.Count > 0)
            foreach (var kv in extraGeometries)
                sb.AppendLine($"            [{enumName}.{kv.Key}] = \"{kv.Value}\",");
        sb.AppendLine($"        }};")
          .AppendLine()
          .AppendLine($"        public static string GetChar(this {enumName} iconCode)")
          .AppendLine($"            => Encoding.UTF32.GetString(BitConverter.GetBytes((uint)iconCode));")
          .AppendLine()
          .AppendLine($"        public static {enumName} Get{enumName}(this string s)")
          .AppendLine($"            => ({enumName})BitConverter.ToUInt32(Encoding.UTF32.GetBytes(s), 0);")
          .AppendLine()
          .AppendLine($"        public static bool IsGeometry(this {enumName} iconCode, out string geometryPath)")
          .AppendLine($"            => GeometryPaths.TryGetValue(iconCode, out geometryPath);")
          .AppendLine($"    }}")
          .AppendLine();


        sb.AppendLine($"    public enum {enumName} : uint")
          .AppendLine("    {");

        if (extraGeometries != null && extraGeometries.Count > 0)
        {
            sb.AppendLine("        // Custom extra codes");
            uint currentId = extraIdStart;
            foreach (var kv in extraGeometries)
            {
                sb.AppendLine($"        {kv.Key} = 0x{Convert.ToString(currentId++, 16).PadLeft(8, '0')}u,");
            }

            sb.AppendLine();
        }

        sb.AppendLine("        // Codes from CSS");
        foreach (var code in codes)
            sb.AppendLine($"        {code.name} = 0x{code.code}u,");

        sb.AppendLine("    }")
          .AppendLine("}");

        Write(sb.ToString());
    }

    private IEnumerable<(string name, string code)> GetCodes(Regex regex, string fileContent)
    {
        foreach (Match match in regex.Matches(fileContent))
        {
            var name = GetName(match.Groups["name"].Value);
            var code = match.Groups["code"].Value.PadLeft(8, '0');
            yield return (name, code);
        }
    }
    
    private string GetName(string name)
    {
        var result = "";
        var nextUpper = true;
        foreach (var c in name)
        {
            if (c == '-')
                nextUpper = true;
            else if (nextUpper)
            {
                result += c.ToString().ToUpper();
                nextUpper = false;
            }
            else
            {
                result += c.ToString().ToLower();
            }
        }

        return result;
    }
#>